D.Srinivas
Corporate Trainer
32 years of experience
15+ programming languages
Trained for CapGemini, Cognizant, InfoSys, Wipro, Samsung, LTI, CGI, Mphasis,CMS etc.,

You can reach me:
Call/WhatsApp : 6305730633
dachepallisrinivas@yahoo.co.in
github.com/dachepallisrinivas-1966

------------------------------------------------------------------------------------------------

Content
+   Core Java
+   MySQL
+   JDBC
+   Servlets
+   JSP


                                                OOPS
                                            --------------
It is an programming paradigm.

Features of Java:
------------------------------
platform independent
    source code : sample.java
    compiler:       sample.class        (byte code)
    byte code is not targeted any o/s.
    it can understood by JVM (Java Virtual Machine)
    byte code to the JVM, it will convert the byte code into native machine code.

secured
robust

simple
portable






object oriented
+   class
+   object
+   data hiding:
        making data members as private, so that we cannot access them 
        from other classes directly.
+   encapsulation:
        it is the process accessing private data with the help of public 
        methods.
        it is implemented in the form of public setters and getters.
+   inheritance
+   abstraction
+   polymorphism

Coding Standards:
---------------------
1) Proper Indentation
2) Naming Convensions
        Camel Notation      :   variables, methods
                int length;
                int lengthOfBox


        Pascal Notation     :   class names, interface names
                class Student {

                }

                ArrayIndexOutOfBoundsException
                 
        Uppercase Notation  :   constants

        Lowercase Notation  :   packages

class:  
    It is a user defined datatype that represent an entity
    in terms of properties and behaviours.
    no memory is allocated when we define a class.
    it is a resuable software component.

    classes are used for different purposes. based on the purpose
    we call them different names.
    
    model      :   to store data

object:
    it is a variable whose datatype is class. 
    memory is allocted only when we create an object for a class.

    syntax:
    -------
    ClassName   objectName;             // reference  (stack)
    objectName = new ClassName();       // object      (heap)

  
package:
    collection of classes, interfaces, enums etc.,
    package is represented as a folder in o/s.

                            domain: www.cms.in
                            package name: in.cms

    in.cms.model        :   all the model classes
    in.cms.ui           :   executable programs


access specifiers: (access modifiers):
1) default          : members under this access can be used in the entire package.
2) private          : members can be accessed only within the class in which it
                        is defined.
3) public           : members can be accessed either within the class or from outside
                        the class.

4) protected        : members can be accessed either within the class or from any of
                        it's sub class.


constructors:
------------------
1. it is a special method that is executed automatically whenever an object is created.
2. it should have the same name as that of class.
3. it can not return any value, should not have void as a return type.
4. it can have parameters.
5. a class can have many constructors. 


"this" reference:
------------------
it represent implied object.
implied object is the one which is invoking a methods currently.


static:
-------
static means "sharable".

1. static data members
        these are used to share common data of all objects of the class.

        private static String companyName;


2. static methods

        they can be called directly with the class name.
        it do not require any object to call.

        JVM will  Call our main() like ...

                ComplexNumberApp.main()

        static methods allow only static data members.

        static methods do not allow "this" keyword.


array of objects:
---------------------
    Product[] products = new Product[5];


inheritance:
---------------
    creating a new class (sub class) from an existing class (super class).
    sub class can access all the featurs of super class as well as any extra features
    that are added to it.
    it represent an "is-A" relationship.
    meant for "code usability."
    "extends" keyword is used to create sub classes.


types:
------
1)  simple (single) inheritance
2)  hierarchical inheritance
3)  multi-level inheritance

note:
------
    multiple inheritance is not supported by java using classes.


method overloading:
    when a class contian more than one method having the same name but with different
    parameter list.

    class  Test {
        public void show(int a) {
            System.out.println(a);
        }
        public void show(double a) {
            System.out.println(a);
        }
        public void show(String a) {
            System.our.println(a);
        }
    }

constructor overloading:
    when a class contain multiple constructors

method overriding:
    when a sub class contain a method that has same signature as that of another 
    method in it's super class, then the sub class method is called as 
    overriding method.

    method signature = method name + parameter list

    "@Override" annotation can be used on top of overriding methods.


    class   Super {
        public int add(int a, int b) {
            return a+b;
        }
    }

    class  Sub   extends  Super {
       @Override
        public int add(int a, int b) {      // overriding method
            return a+b+100;
        }
    }

    super:
    -------
        the "super" keyword can used to refer super class data members,
        super class methods, super class constructors from the sub class.

        super();                        call the super class default constructor
        super(arg-1, arg-2, ...)        call the super class parameter constructor
        super.dataMemberName
        super.method(arg-1, arg-2, ...)


                                    Person (name, age)

                                    Employee (salary)               

5-Dec-2022
----------------------

hierarchical inheritance:
--------------------------

                                     Person (name, age)

                        Employee (salary)               Student (fee)

multi level inheritance:
-------------------------

                                    Person (name, age)

                                    Employee (salary) extends Person

                                    Manager (bonus) extends Employee

create the necessary classes and the App also.


polymorphism:
---------------
    poly = many
    morph = forms

    exhibiting different behaviours for a same method call.

                                move()

            man         ----------------------->        walk
            fish        ----------------------->        swim
            bird        ----------------------->        fly
            snake       ----------------------->        crawl

    move() is exhibiting different behaviours and hence it is known as polymohic method.


note:
-----
    super class reference variable can store super class object or objects of any sub class
    of it.


                Peron
    Employee            Student

    Manager


    Person person = new Person();
    Person person = new Employee();
    Person person = new Student();
    Employee employee = new Manager();
    Person person = new Manager();



    Task:
    -----

    class   A {
            public void show() {
                System.out.println("A - show");
            }
        }

        class   B  extends  A {
            public void print() {
                System.out.println("B - print");
            }
        }

        class   Test {
            public static void main(String[] args) {
                B obj = new B();
                obj.show();         // A - show
                obj.print();        // B - print

                A obj2 = new A();
                obj2.show();        // A - show
                obj2.print();       // error


                A obj3 = new B();   
                obj3.show();        // A - show
                obj3.print();       // error
            }
        }


                                    Object class            (java.lang package):
                                   ----------------------------------------------
+   it is known as "universal super class".
+   every class whether it is a pre-defined or user-defined, it is inherited automatically
    from java.lang.Object class.

java.lang.Object class methods:
-------------------------------
1) public String toString()
        it is generally used to convert the object data into string.
        it is provided with default definition.
        (fully-qualified-class-name + "@" + hashcode-in-hexa-decimal-form)

2) public boolean equals(Object o)
        it is used to implement our own logic for object comparision.


                                                abstraction
                                            ---------------------            
abstract means "incomplete".
abstraction is the feature of disclosing only the features without exposing the background functionality.

abstract keyword can be used in two ways.
a) abstract class
b) abstract method


abstract class:
-----------------
    it is a class for which we cannot create an object for it.


                                            abstract class  Person (name, age)

                                Employee (salary)                           Student (fee)


abstract method:
    it is a method declaration with "abstract" keyword without any definition.
    it must be defined only inside an abstract class.
    abstract methods can be defined only in an abstract class. 
    But an abstract class need not contain any abstract methods.

    to make of use of this abstract class, create a sub class and override all abstract methods in it.
    then create objects for this abstract class and use it.


    public abstract class  A {
        public abstract void show();
    }


    class  B  extends  A {
        @Override
        public void show() {
            System.out.println("some definition ...");
        }
    }

    class Test {
        public static void main(String[] args) {
            B obj = new B();
            obj.show();
        }
    }




final:
-------
    can be used in 3 ways.

    a) final variable:
            these are known as constants.

            final double PI = 3.14;
            double areaOfCirlce = PI * radius * radius;  

    b) final methods:

            we cannot override final methods.

            class  Sample {

                public final void show() {
                    // logic
                }

            }

            class  SubSample {

                @Override
                public void show() {
                    // error - we can't override final method
                } 

            }

    c) final class:

            we can't create sub class for it.

            eg: java.lang.Math 





                                                interfaces
                                            -------------------
interface is also user-defined datatype.
it does not contain properties.
it can contain only public abstract methods and public static final variables.
we cannot create object for an interface.

to use the interface, we must create a sub class using "implements" and override all abstract methods.
then create object for this sub class.

using interfaces, we can acheive multiple inheritance.
we can create a class from many interfaces. (multiple inheritance)



class               extends             sub class
interface           implements          sub class
interface           extends             sub interface


class               implements          interface-1, interface-2, ...

class               implements          interface      extends         class


interface   EmployeeRepository {
    void save(Employee employee);
    void findById(Long empId);
}


class       EmployeeRepositoryImpl   implements   EmployeeRepository {

    @Override
    public void save(Employee  employee) {
        // logic goes here ....
    }

    @Override
    piublic void findById(Long empId){
        // logic goes here ...
    }

}

class    Test {
    public static void main(String[] args) {
        EmployeeRepositoryImpl  obj = new EmployeeRepositoryImpl();
        obj.save(new Employee(101, "srinivas", 50000.0));
    }
}


                                        Built-In Packages
						                ------------------
                                        (Java SE Libraries)

java.lang			(default package - because it is imported for every program)
	Object          
	System
	Math
	String
	StringBuffer
	StringBuilder
	Exception
	Throwable interface
	Runnable interface
	Wrapper classes - Integer, Double, Float, Long, Boolean


java.util
    Scanner
   
java.io
    FileReader
    BufferedReader

to use any class, we need to specify fully qualified class name.(eg: packagename.classname) 
or import them.

java.lang is the default package. it is automatically imported for every program.

java.lang.System class:
   -------------------------------

	class variables			              object
	-------------------				    ---------
	public static java.io.InputStream		in
	public static java.io.PrintStream		out
	public static java.io.PrintStream		err

	System.in	carries signal from keyboard to VDU.
	System.out, System.err carries signal directly to VDU.


	methods:
	------------
	public static void gc();		request for garbage collection.
	public static void exit(int)	terminates the program then and there. int could be either a 0 or 1.
    String getEnvironmentVariable(String varName);
    void setEnvironmentVariable(String varName,String value);


java.lang.Math
-------------------
	public static fields:
	------------------------
		E, PI
    	
	public static methods
	----------------------------
		double pow()
		double sin(angle in radians)
            Math.sin(30)    =>  ???
            Math.sin(Math.toRadians(30))    =>  0.5

        double cos(angle in radians)
		double sqrt()

		ceil() : return next integer
            Math.ceil(11.2) => 12
		floor() : return previous integer
            Math.floor(11.9) => 11
		round() 
            Math.round(11.2) =>  11
            Math.round(11.9) =>  12

		abs() : return |n|
		toRadians()
		toDegrees()

java.lang.String
---------------------
	String is immutable	(not modifiable).
    what is immutability?
      ???

	creating object:
	---------------------
	1) String	str;
	2) String	str = new String();

	3) String	str = "hello";
	4) String	str = new String("hello");
  

	methods:
	-------------
	1) length()		2) toUpperCase()		3) toLowerCase()
	4) indexOf(String)	5) lastIndexOf(String)		6) startsWith(String)
	7) endsWith(String)	8) contains(String)		9) charAt(index)
	10) substring(start_index_usiveincl [, end_index_exclusive] )		11) split()
	12) equals(String)	13) equalsIgnoreCase(String)	14) compareTo(String)
	15) valueOf()		16) format()        17) replace(old_char, new_char)

    18) join()  - JDK 1.8

    "+" string concatenation operator


    write a program to reverse a string.
    input = abcd
    output = bcda

    


String constant pool (String literal pool)
------------------------------------------
    This is a special memory used to store string constants.


java.lang.StringBuffer and java.lang.StringBuilder:
------------------------------------------------------------------
	StringBuffer is thread-safe. (synchronized)
	StringBuilder is not thread-safe.

	They are mutable (modifiable).

	a) capacity()
	b) append()
	c) insert()
	d) delete()
	e) reverse()


Wrapper Classes                     static method
---------------------               ---------------------------------
    java.lang.Integer               parseInt(string-form-int)
    java.lang.Short
    java.lang.Byte
    java.lang.Double                parseDouble(string-form-double)
    java.lang.Boolean
    java.lang.Float
    java.lang.Character
    java.lang.Long


every wrapper class provide two constants.
    MIN_VALUE 
    MAX_VALUE


    String str = "123";
    int num = Integer.parseInt(str);        // num = 123
    System.out.println(num * 2);

    System.out.println(Integer.MAX_VALUE);
    System.out.println(Integer.MIN_VALUE);


 Boxing:
    primitive variable into a wrapper object

    int x = 89;
    Integer iobj = x;   //auto-boxing

 unBoxing:
    wrapper object into primitive variable
 
    Integer iobj = new Integer(109);
    int x = iobj; // auto-unboxing

static import: (JDK 1.5)
------------------------
    java.lang.Math class provide static methods.
        sqrt()
        abs()
        pow()

    int a, b;
    double hypotenuse = Math.sqrt(Math.pow(a,2) + Math.pow(b,2));

    (or)
    import static java.lang.Math.sqrt;
    import static java.lang.Math.pow;

    double hypotenuse = sqrt(pow(a,2) + pow(b,2));


    import java.util.Scanner;       // recommended
    import java.util.*;             // bad coding practice



                                    Exception Handling
                                ---------------------------

    Error is detected by the compiler. The program will not be executed until we resolve them.
        a) forgot to put a semi-colon(;)
        b) wrong syntaxes
        c) misspelt names etc.,

    Exception means an unexpected event that is triggered in the program upon which the
    program is abruptly terminated.

    Every exception is a class (pre-defined)

    Exception Details:  (Exception Stack Trace)
    ----------------------------------------------
        what is the exception message?          ...
        what is the exception class name?       java.io.InputMismatchException
        in which package?                       in.cms.ui
        in which class exception occurred?      ExceptionDemo
        in which method exception occurred?     main
        what is the line number?                11
  

    Exception in thread "main" java.lang.ArithmeticException: / by zero
	at in.cms.ui.ExceptionDemo.main(ExceptionDemo.java:18)

        what is the exception message?          / by zero
        what is the exception class name?       java.lang.ArithmeticException
        in which package?                       in.cms.ui
        in which class exception occurred?      ExceptionDemo
        in which method exception occurred?     main
        what is the line number?                18

    If we handle exception, the program will not be terminated. The execution is continued
    by taking an appropriate action regarding that exception.

    To handle exceptions, we have 5 keywords.
        a) try
        b) catch
        c) finally
        d) throw
        c) throws

    try
    {
        // code to be monitored by jvm
        // if ExceptionClassName1 occurred, the control go to the catch block 1, 
            then the finally block.
        // if ExceptionClassName2 occurred, the control go to the catch block 2, 
            then the finally block.
        // if any other exception occurred, it go to the finally block and then 
            the program is terminated.

        // if no exceptions are occurred, then the finally block is executed.

    }
    catch(ExceptionClassName1  excep)
    {
        // action to be taken when the ExceptionClassName1 occurred in the try block.
    }
    catch(ExceptionClassName2  excep)
    {
        // action to be taken when the ExceptionClassName2 occurred in the try block.
    }
    finally
    {
        // action to be taken whether an exception occurred or not.
    }

note:
-----
    every try block must have at least one catch block or finally block.
    we cannot write any statements between try and catch.
    one try block can have many catch blocks.

    one try can have another try within it.



    Exceptions may or maynot reported by the compiler. 
    If exception is not reported by the compiler, it is known as UncheckedExceptions.
    Unchecked exceptions are inherited from java.lang.RuntimeException class.
    Unchecked exceptrions are reported by interpreter (JRE)

    
    if exception is reported by the compiler, it is known as CheckedExceptions.
    CheckedExceptions must be handled using try and catch, then only we can execute the 
    program.
    All checked exceptions are inherited from java.lang.Exception class.



                                        Object

                                        Throwable

                                        Exception

                        IOException                 RuntimeException
                        SQLException
                        ClassNotFoundException              InputMismatchException
                                                            ArithmeticException
                                                            StringIndexOutOfBoundsException
                                                            ArrayIndexOutOfBoundsException
                                                            NegativeArraySizeException

    throw:
        is used to raise an exception explicitly (programmatically)

        syntax:
            throw new UserDefinedExceptionClassName();


                                    user defined exceptions
                                --------------------------------
    1. create a class, must be inherited from Exception class.

    throws:
    -------
        is used to delegate the exception handling reponsibility to the caller
        of the method.



        class   JavaTrainer   {

            public static void main() throws  NetWorkException, TransportException {
                try {
                    throw new DoubtsClarificationException();       // 1.

                    throw new QuickRecapException();                // 2.

                    throw new ResumeBuildingException();            // 3.



                } catch(DoubtsClarificationException excep) {

                } catch(QuickRecapException excep) {

                } catch(ResumeBuildingException excep) {

                }
            }
        }


    class Shopping {

        public void purchase(Card card) throws CardDeclinedException {
            // 
        }

        public void purchase(Cash cash) {
            // payment with cash
        }
    }

    class Customer {
        public void shopping() {
            Shopping shopping = new Shopping();
            try {
                shopping.purchase(creditCard);
            } catch(CardDeclinedException excep) {
                shopping.purchase(cash);
            }
        }
    }


1.card may be blocked.
2.insufficient balance
3.bad network




int a,b,c;

store 1000 numbers?         will you take 1000 variables?       NO


int[] arr = new int[1000];
arr[0] = 10
arr[1] = 5.6;       // not allowed
arr[1] = 20;
arr[2] = 30;
arr[3] = 40;
...

10  20  30  40
10  30  40


        

1. the size of the array is fixed.
2. array is homogeneous.
3. insertion, deletion, sort, search - basic operations are also not supported.


                                            Collections Framework (Collections API)
                                                    (java.util)
                                        ----------------------------------------------
provide set of interfaces, implementation classes, readymade methods.

1. size is not fixed.
2. it can be homogeneous or heterogeneous
3. ready made methods available to do operations.


                                                Collections Hierarchy
                                                ---------------------
                                    

                                    Iterable (i)

                                    Collection (i)                                  Map (i)

                        List (i)                    Set(i)                         

                        ArrayList                       HashSet                     HashMap 
                        LinkedList                      LinkedHashSet               LinkedHashMap
                                                        TreeSet                     TreeMap

Collections are used to store objects.

1) raw collection           (heterogeneous - not recommended)
2) generic collection       (homogeneous - recommended)
    provide type safety.


cursors:
---------
1) Iterator




List:
    1. duplicates are allowed.
    2. index based operations

    add()
    remove()
    set()
    get()
    size()

    ArrayList:
    ----------
        List list = new ArrayList();

        ArrayList list = new ArrayList();

        clear()     :   to remove all elements
        contains()  :   to search for an element

        is best when modifications are less frequent.

    LinkedList:
    ------------
        List list = new LinkedList();

        LinkedList list = new LinkedList();

        is best when modifications are frequent.

        a) addFirst()
        b) addLast()
        c) removeFirst()
        d) removeLast()

    Queue:
    ---------
        FIFO



Set:
    1. no duplicates
    2. no index based operations


    HashSet             :   order is not guaranteed
    LinkedHashSet       :   insertion order
    TreeSet             :   sorted order

    does set allow null values?



Map:
    1. collection of key-value pairs.
    2. key cannot be duplicated.
    3. value can be duplicated.
    4. key cannot be null.
    5. value can be null.
    6. do not follow index

    HashMap             :   order is not guaranteed
    LinkedHashMap       :   insertion order
    TreeMap             :   sorted order on key

    put(key, value)
    value get(key)
    Set<key>    keySet()
    boolean containsKey(key)
    Collection values()

    Entry : key + value


java.util.Comparable<T> (I)
----------------------------
    int compareTo(o)
        if both objects are equal, we should return 0.
        if invoking object is bigger return a +ve value (1)
        if invoking object is smaller return a -ve value (-1)



java.util.Collections class provide utility methods:
------------------------------------------------------
a) sort(Collection)                 : natural sorting order
b) sort(Collection, Comparator)     : custom comparator


java.util.Comparator<T> (I):
---------------------------------
    int compare(o1, o2)
     if both objects are equal, we should return 0.
        if invoking object is bigger return a +ve value (1)
        if invoking object is smaller return a -ve value (-1)

    
contract between equals and hashcode()?
------------------------------------------
    if two objects are equal as per the equals(), then objects must have same hash code.
    but vice versa is not necessary.




                                            MySQL
                                        -------------
1. It is an RDBMS product.
2. It uses SQL () to communicate with Database.
3. SQL commands ...
    a) DDL          :   CREATE/ALTER/DROP/TRUNCATE/RENAME
    b) DML          :   INSERT/UPDATE/DELETE
    c) DCL          :   GRANT/REVOKE
    d) TCL          :   COMMIT/ROLLBACK
    e) DRL / DQL    :   SELECT


    Integrity Constraints:
    ------------------------
    1) PRIMARY KEY
    2) FOREIGN KEY  (REFERENCES)
    3) NOT NULL
    4) UNIQUE
    5) CHECK (condition)

    primary key:
    ------------
    1. it is a column or combination of columns that identify each row uniquely.
    2. a table can have one primary key
    3. it does not allow null values.
    4. it does not allow duplicate values.

    foreign key:
    ------------
    1. it is a column or combination of columns that is used to establish relation between a child to 
       parent table.
    2. a table can have many foreign keys.
    3. it allow duplicate values
    4. it allow null values
    5. every foreign key must be defined as primary key in it's parent table.



    INSERT:
        INSERT INTO tablename [(col-1, col-2, ...)]
        VALUES (value-1, value-2 ....);

    UPDATE:
        UPDATE  tablename
        SET   col-1 = value-1  [, col-2 = value-2, ...]
        [WHERE  condition];

    DELETE:
        DELETE FROM tablename
        [WHERE  condition];

    DROP TABLE:
        DROP  TABLE  tablename;


    SELECT:
    -------
        to retrieve value from a table.

        SELECT * FROM tablename;
        SELECT columnlist FROM tablename;

        select employee_id, first_name, salary from employees;

        we can perform ...
        a) arithmetic operations
        b) column alias
  

        calculate the monthly salary of all employees.

        select employee_id, first_name, salary, commission_pct, salary+(salary*commission_pct)
        from employees;

        null:
        -----
        when a column lacks value then it is said to be null.
        a null is either unassigned, unpredicted or undetermined.
        it is not same as zero.
        any arithmetic operation performed with null value leads to null result.

        ifnull():
        ---------
        select employee_id, first_name, salary, commission_pct, salary+(salary*ifnull(commission_pct,0))
        from employees;

        distinct qualifier:
        --------------------
        to eliminate duplicate rows in the output.


        operators:
        -------------
        1) arithmetic operators :   +   -   *   /   
        2) relational operators:    >   <   =   >=  <=  != 
        3) logical operators:   and     or      not


        WHERE clause:
        -------------
        1) display all employees who earn more than 15000.

        select employee_id, first_name, salary from employees where salary > 15000;

        2) display all employees who belong to 50 department.

        select employee_id, first_name, salary, department_id from employees where department_id = 50;

        3) display all sales managers.

        select employee_id, first_name, job_id from employees where job_id = 'sa_man';

        4) display all employees who were hired in the year 1997.

            select employee_id, first_name, hire_date
            from employees
            where hire_date like '1997%';

            select employee_id, first_name, job_id, hire_date 
            from employees 
            where extract(YEAR from hire_date) = 1997;

            ????

        5) display all employees whose first name begin with alphabet S.

        select employee_id, first_name
        from employees
        where first_name like 'S%';

        6) display all employees whose first name ends with alphabet 'n'.

        select employee_id, first_name
        from employees
        where first_name like '%n';

        7) display all employees whose first name contain second character as 'o'.

        select employee_id, first_name
        from employees
        where first_name like '_o%';

        8) display all employees who do not earn any commission.

        select employee_id, first_name, commission_pct
        from employees
        where commission_pct is null;


        joins
        sub queries
 

    group (aggregate) functions :
    ------------------------------
            these functions work on groups of rows rather than the entire table.

        sum(col/val)
        avg(col/val)
        count(col/val)
        min(col/val)
        max(col/val)        

    display total salary of employees.

        select sum(salary) from employees;
        select avg(salary) from employees;

    display maximum salary of all employees working in department 50.
        select max(salary) from employees where department_id = 50;

    display total number of it programmers.
        select count(*) from employees where job_id = 'IT_PROG';


    GROUP BY:
    ----------
        used to divide rows into groups, so that we can perform aggregate
        functions on each group.

        SELECT   col/*
        FROM    tablename
        [WHERE  condition]
        [GROUP  BY  col-1, col-2, ...]
        [ORDER  BY  col-1, col-2, ...];

    display total salary of each department.

        select  department_id, sum(salary)
        from employees
        group by department_id;

    display total number of employees for each job.

        select job_id, count(*)
        from employees
        group by job_id;

    display average salary of each departments whose id is more than 50.

        select department_id, avg(salary)
        from employees
        where department_id > 50
        group by department_id;

    display total salary of each job which is more than 10000.

        select job_id, sum(salary)
        from employees
        where sum(salary) > 10000
        group by job_id;

    note:
    ------
        we cannot use aggregate functions in the where clause. 


    HAVING clause:
    --------------
        is used to filter rows after grouping.
        is always in conjunction with GROUP BY.


    select job_id, sum(salary)
    from employees
    group by job_id
    having sum(salary) > 10000;

    what is the difference between where and having?

        WHERE is used to filter rows before grouping
        HAVING is used to filter rows after grouping

    
                                JOINS
                            --------------
    
    to retrieve data from multiple related tables.
    both the tables must have a common column.

    1) inner join       : consider only matching rows.
    2) outer join       : matching rows + unmatched rows
            i) left outer join      :   matching rows + unmatched rows from left table
            ii) right outer join    :   matching rows + unmatched rows from right table



    display employee id, first name, department name of all employees.

    select employee_id, first_name, department_name
    from employees              // left table
    join departments            // right table
    using (department_id);


    emp                                     dept

    101     john    10                      10      sales
    102     david   10                      20      it
    103     meena   20                      30      finance
    104     radha   ..      // ignored

                    output

        101    john         sales
        102    david        sales
        103     meena       it


    select employee_id, first_name, department_name
    from employees              
    left outer join departments           
    using (department_id);

                        output
        
        101    john         sales
        102    david        sales
        103    meena        it
        104    radha        ..

    select employee_id, first_name, department_name
    from employees              
    right outer join departments           
    using (department_id);

                       output
        
        101    john         sales
        102    david        sales
        103    meena        it
        ..       ..         finance

    

                                            JDBC API
                                (Java Database Connectivity)
                            -------------------------------------
    API     stands for Application Programming Interface.
            collection interfaces, abstract classes etc.,


    implementations are provided by DB Vendors.

    MYSQL           MySQL implementation classes of JDBC API
    Oracle          Oracle implementation classes of JDBC API
    etc.,

    .jar file       implementations of any API

    JDBC Driver     it is a jar (Java Archive File)
                    any jar contain several .class files.


    java.sql package
    -----------------------
    Connection (I)
    +   Statement createStatement()
    +   PreparedStatement prepareStatement(sql)
    DriverManager (A)
    +   getConnection(url, userName, password)
    Statement (I)
    +   executeUpdate(sql)
    PreparedStatement (I)
    +   executeUpdate()     for insert/update/delete
    +   ResultSet executeQuery()      for select
    ResultSet (I)
    +   to retrieve the data from the database.
    +   next()
    +   getxxx(column_number / column_name)


    steps:
    ------
    1. load the driver class
    2. establish a connection
    3. create a statement and associate with the sql command
    4. execute the sql command
    5. once the job is done, close the connection and other resources.


write an update program to modify the salary of an employee for
the given empno.

write a delete program to delete an employee when the empno is given.



CRUD operation:
    Create
    Retrieve
    Update
    Deletion



    





    


    

    

















Assignments:
------------
1) include toString() in Person, Employee, Student, Manager class.
   modify the InheritanceApp program accordingly.

2) Create a Product class
        prodName, price
   Store 10 products in an array.
   write a program to display all the products.


3) What is the antonym keyword  for "final"?
4) what is the difference between JDK, JVM, JRE?
5) can we overload static methods?  
6) can we override static methods?          
7) can we have static classes?


8) what is static block?



create a class called "Point".
    data members : x, y
    initialize the point object with 0,0 if no values are given.
    initialize the point object with the given values.
    find the distance between to given points.
    find the mid point of two given points.
    find whether three given points form a triangle or not.

    No need to write the App. It can be done later.

Reverse String program using StringBuilder.

9) what is the need of Comparable and Comparator?






































