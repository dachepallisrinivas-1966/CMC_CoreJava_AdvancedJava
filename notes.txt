D.Srinivas
Corporate Trainer
32 years of experience
15+ programming languages
Trained for CapGemini, Cognizant, InfoSys, Wipro, Samsung, LTI, CGI, Mphasis etc.,

You can reach me:
Call/WhatsApp : 6305730633
dachepallisrinivas@yahoo.co.in
github.com/dachepallisrinivas-1966

------------------------------------------------------------------------------------------------

Content
+   Core Java
+   MySQL
+   JDBC
+   Servlets
+   JSP


                                                OOPS
                                            --------------
It is an programming paradigm.

Features of Java:
------------------------------
platform independent
    source code : sample.java
    compiler:       sample.class        (byte code)
    byte code is not targeted any o/s.
    it can understood by JVM (Java Virtual Machine)
    byte code to the JVM, it will convert the byte code into native machine code.

secured
robust

simple
portable






object oriented
+   class
+   object
+   data hiding:
        making data members as private, so that we cannot access them 
        from other classes directly.
+   encapsulation:
        it is the process accessing private data with the help of public 
        methods.
        it is implemented in the form of public setters and getters.
+   inheritance

+   abstraction
+   polymorphism

Coding Standards:
---------------------
1) Proper Indentation
2) Naming Convensions
        Camel Notation      :   variables, methods
                int length;
                int lengthOfBox


        Pascal Notation     :   class names, interface names
                class Student {

                }

                ArrayIndexOutOfBoundsException
                 
        Uppercase Notation  :   constants

        Lowercase Notation  :   packages

class:  
    It is a user defined datatype that represent an entity
    in terms of properties and behaviours.
    no memory is allocated when we define a class.
    it is a resuable software component.

    classes are used for different purposes. based on the purpose
    we call them different names.
    
    model      :   to store data

object:
    it is a variable whose datatype is class. 
    memory is allocted only when we create an object for a class.

    syntax:
    -------
    ClassName   objectName;             // reference  (stack)
    objectName = new ClassName();       // object      (heap)

  
package:
    collection of classes, interfaces, enums etc.,
    package is represented as a folder in o/s.

                            domain: www.cms.in
                            package name: in.cms

    in.cms.model        :   all the model classes
    in.cms.ui           :   executable programs


access specifiers: (access modifiers):
1) default          : members under this access can be used in the entire package.
2) private          : members can be accessed only within the class in which it
                        is defined.
3) public           : members can be accessed either within the class or from outside
                        the class.

4) protected        : members can be accessed either within the class or from any of
                        it's sub class.


constructors:
------------------
1. it is a special method that is executed automatically whenever an object is created.
2. it should have the same name as that of class.
3. it can not return any value, should not have void as a return type.
4. it can have parameters.
5. a class can have many constructors. 


"this" reference:
------------------
it represent implied object.
implied object is the one which is invoking a methods currently.


static:
-------
static means "sharable".

1. static data members
        these are used to share common data of all objects of the class.

        private static String companyName;


2. static methods

        they can be called directly with the class name.
        it do not require any object to call.

        JVM will  Call our main() like ...

                ComplexNumberApp.main()

        static methods allow only static data members.

        static methods do not allow "this" keyword.


array of objects:
---------------------
    Product[] products = new Product[5];


inheritance:
---------------
    creating a new class (sub class) from an existing class (super class).
    sub class can access all the featurs of super class as well as any extra features
    that are added to it.
    it represent an "is-A" relationship.
    meant for "code usability."
    "extends" keyword is used to create sub classes.


types:
------
1)  simple (single) inheritance
2)  hierarchical inheritance
3)  multi-level inheritance

note:
------
    multiple inheritance is not supported by java using classes.


method overloading:
    when a class contian more than one method having the same name but with different
    parameter list.

    class  Test {
        public void show(int a) {
            System.out.println(a);
        }
        public void show(double a) {
            System.out.println(a);
        }
        public void show(String a) {
            System.our.println(a);
        }
    }

constructor overloading:
    when a class contain multiple constructors

method overriding:
    when a sub class contain a method that has same signature as that of another 
    method in it's super class, then the sub class method is called as 
    overriding method.

    method signature = method name + parameter list

    "@Override" annotation can be used on top of overriding methods.


    class   Super {
        public int add(int a, int b) {
            return a+b;
        }
    }

    class  Sub   extends  Super {
       @Override
        public int add(int a, int b) {      // overriding method
            return a+b+100;
        }
    }

    super:
    -------
        the "super" keyword can used to refer super class data members,
        super class methods, super class constructors from the sub class.

        super();                        call the super class default constructor
        super(arg-1, arg-2, ...)        call the super class parameter constructor
        super.dataMemberName
        super.method(arg-1, arg-2, ...)


                                    Person (name, age)

                                    Employee (salary)               

5-Dec-2022
----------------------

hierarchical inheritance:
--------------------------

                                     Person (name, age)

                        Employee (salary)               Student (fee)

multi level inheritance:
-------------------------

                                    Person (name, age)

                                    Employee (salary) extends Person

                                    Manager (bonus) extends Employee

create the necessary classes and the App also.


polymorphism:
---------------
    poly = many
    morph = forms

    exhibiting different behaviours for a same method call.

                                move()

            man         ----------------------->        walk
            fish        ----------------------->        swim
            bird        ----------------------->        fly
            snake       ----------------------->        crawl

    move() is exhibiting different behaviours and hence it is known as polymohic method.


note:
-----
    super class reference variable can store super class object or objects of any sub class
    of it.


                Peron
    Employee            Student

    Manager


    Person person = new Person();
    Person person = new Employee();
    Person person = new Student();
    Employee employee = new Manager();
    Person person = new Manager();



    Task:
    -----

    class   A {
            public void show() {
                System.out.println("A - show");
            }
        }

        class   B  extends  A {
            public void print() {
                System.out.println("B - print");
            }
        }

        class   Test {
            public static void main(String[] args) {
                B obj = new B();
                obj.show();         // A - show
                obj.print();        // B - print

                A obj2 = new A();
                obj2.show();        // A - show
                obj2.print();       // error


                A obj3 = new B();   
                obj3.show();        // A - show
                obj3.print();       // error
            }
        }


                                    Object class            (java.lang package):
                                   ----------------------------------------------
+   it is known as "universal super class".
+   every class whether it is a pre-defined or user-defined, it is inherited automatically
    from java.lang.Object class.

java.lang.Object class methods:
-------------------------------
1) public String toString()
        it is generally used to convert the object data into string.
        it is provided with default definition.
        (fully-qualified-class-name + "@" + hashcode-in-hexa-decimal-form)

2) public boolean equals(Object o)
        it is used to implement our own logic for object comparision.


                                                abstraction
                                            ---------------------            
abstract means "incomplete".
abstraction is the feature of disclosing only the features without exposing the background functionality.

abstract keyword can be used in two ways.
a) abstract class
b) abstract method


abstract class:
-----------------
    it is a class for which we cannot create an object for it.


                                            abstract class  Person (name, age)

                                Employee (salary)                           Student (fee)


abstract method:
    it is a method declaration with "abstract" keyword without any definition.
    it must be defined only inside an abstract class.
    abstract methods can be defined only in an abstract class. 
    But an abstract class need not contain any abstract methods.

    to make of use of this abstract class, create a sub class and override all abstract methods in it.
    then create objects for this abstract class and use it.


    public abstract class  A {
        public abstract void show();
    }


    class  B  extends  A {
        @Override
        public void show() {
            System.out.println("some definition ...");
        }
    }

    class Test {
        public static void main(String[] args) {
            B obj = new B();
            obj.show();
        }
    }




final:
-------
    can be used in 3 ways.

    a) final variable:
            these are known as constants.

            final double PI = 3.14;
            double areaOfCirlce = PI * radius * radius;  

    b) final methods:

            we cannot override final methods.

            class  Sample {

                public final void show() {
                    // logic
                }

            }

            class  SubSample {

                @Override
                public void show() {
                    // error - we can't override final method
                } 

            }

    c) final class:

            we can't create sub class for it.

            eg: java.lang.Math 





                                                interfaces
                                            -------------------
interface is also user-defined datatype.
it does not contain properties.
it can contain only public abstract methods and public static final variables.
we cannot create object for an interface.

to use the interface, we must create a sub class using "implements" and override all abstract methods.
then create object for this sub class.

using interfaces, we can acheive multiple inheritance.
we can create a class from many interfaces. (multiple inheritance)



class               extends             sub class
interface           implements          sub class
interface           extends             sub interface


class               implements          interface-1, interface-2, ...

class               implements          interface      extends         class


interface   EmployeeRepository {
    void save(Employee employee);
    void findById(Long empId);
}


class       EmployeeRepositoryImpl   implements   EmployeeRepository {

    @Override
    public void save(Employee  employee) {
        // logic goes here ....
    }

    @Override
    piublic void findById(Long empId){
        // logic goes here ...
    }

}

class    Test {
    public static void main(String[] args) {
        EmployeeRepositoryImpl  obj = new EmployeeRepositoryImpl();
        obj.save(new Employee(101, "srinivas", 50000.0));
    }
}


                                        Built-In Packages
						                ------------------
                                        (Java SE Libraries)

java.lang			(default package - because it is imported for every program)
	Object          
	System
	Math
	String
	StringBuffer
	StringBuilder
	Exception
	Throwable interface
	Runnable interface
	Wrapper classes - Integer, Double, Float, Long, Boolean


java.util
    Scanner
   
java.io
    FileReader
    BufferedReader

to use any class, we need to specify fully qualified class name.(eg: packagename.classname) 
or import them.

java.lang is the default package. it is automatically imported for every program.

java.lang.System class:
   -------------------------------

	class variables			              object
	-------------------				    ---------
	public static java.io.InputStream		in
	public static java.io.PrintStream		out
	public static java.io.PrintStream		err

	System.in	carries signal from keyboard to VDU.
	System.out, System.err carries signal directly to VDU.


	methods:
	------------
	public static void gc();		request for garbage collection.
	public static void exit(int)	terminates the program then and there. int could be either a 0 or 1.
    String getEnvironmentVariable(String varName);
    void setEnvironmentVariable(String varName,String value);


java.lang.Math
-------------------
	public static fields:
	------------------------
		E, PI
    	
	public static methods
	----------------------------
		double pow()
		double sin(angle in radians)
            Math.sin(30)    =>  ???
            Math.sin(Math.toRadians(30))    =>  0.5

        double cos(angle in radians)
		double sqrt()

		ceil() : return next integer
            Math.ceil(11.2) => 12
		floor() : return previous integer
            Math.floor(11.9) => 11
		round() 
            Math.round(11.2) =>  11
            Math.round(11.9) =>  12

		abs() : return |n|
		toRadians()
		toDegrees()

java.lang.String
---------------------
	String is immutable	(not modifiable).
    what is immutability?
      ???

	creating object:
	---------------------
	1) String	str;
	2) String	str = new String();

	3) String	str = "hello";
	4) String	str = new String("hello");
  

	methods:
	-------------
	1) length()		2) toUpperCase()		3) toLowerCase()
	4) indexOf(String)	5) lastIndexOf(String)		6) startsWith(String)
	7) endsWith(String)	8) contains(String)		9) charAt(index)
	10) substring(start_index [, end_index] )		11) split()
	12) equals(String)	13) equalsIgnoreCase(String)	14) compareTo(String)
	15) valueOf()		16) format()        17) replace(old_char, new_char)

    18) join()  - JDK 1.8

    "+" string concatenation operator


    write a program to reverse a string.
    input = abcd
    output = bcda

    


String constant pool (String literal pool)
------------------------------------------
    This is a special memory used to store string constants.


java.lang.StringBuffer and java.lang.StringBuilder:
------------------------------------------------------------------
	StringBuffer is thread-safe. (synchronized)
	StringBuilder is not thread-safe.

	They are mutable (modifiable).

	a) capacity()
	b) append()
	c) insert()
	d) delete()
	e) reverse()

StringJoiner (jdk 1.8)
    used to join group of Strings.

    StringJoiner(delimiter)
    StringJoiner(delimiter, prefix, suffix)
    merge()

StringTokenizer (java.util)         -- Legacy Class
    to split the string into words based on the delimiter given.

    StringTokenizer(string, delimiter, boolean returnDelims)

    hasTokens()
    nextToken()

    Since it is a legacy class, we can use split() of String class, which offer better
    performance.



Wrapper Classes                     static method
---------------------               ---------------------------------
    java.lang.Integer               parseInt(string-form-int)
    java.lang.Short
    java.lang.Byte
    java.lang.Double                parseDouble(string-form-double)
    java.lang.Boolean
    java.lang.Float
    java.lang.Character
    java.lang.Long

every wrapper class provide two constants.
    MIN_VALUE 
    MAX_VALUE

 Boxing:
    primitive variable into a wrapper object

    int x = 89;
    Integer iobj = x;   //auto-boxing

 unBoxing:
    wrapper object into primitive variable
 
    Integer iobj = new Integer(109);
    int x = iobj; // auto-unboxing

static import: (JDK 1.5)
------------------------
    java.lang.Math class provide static methods.
        sqrt()
        abs()
        pow()

    int a, b;
    double hypotenuse = Math.sqrt(Math.pow(a,2) + Math.pow(b,2));

    (or)
    import static java.lang.Math.sqrt;
    import static java.lang.Math.pow;

    double hypotenuse = sqrt(pow(a,2) + pow(b,2));


    import java.util.Scanner;       // recommended
    import java.util.*;             // bad coding practice





Assignments:
------------
1) include toString() in Person, Employee, Student, Manager class.
   modify the InheritanceApp program accordingly.

2) Create a Product class
        prodName, price
   Store 10 products in an array.
   write a program to display all the products.


3) What is the antonym keyword  for "final"?
4) what is the difference between JDK, JVM, JRE?
5) can we overload static methods?
6) can we oberride static methods?
7) can we have static classes?























