D.Srinivas
Corporate Trainer
32 years of experience
15+ programming languages
Trained for CapGemini, Cognizant, InfoSys, Wipro, Samsung, LTI, CGI, Mphasis etc.,

You can reach me:
Call/WhatsApp : 6305730633
dachepallisrinivas@yahoo.co.in
github.com/dachepallisrinivas-1966

------------------------------------------------------------------------------------------------

Content
+   Core Java
+   MySQL
+   JDBC
+   Servlets
+   JSP


                                                OOPS
                                            --------------
It is an programming paradigm.

Features of Java:
------------------------------
platform independent
    source code : sample.java
    compiler:       sample.class        (byte code)
    byte code is not targeted any o/s.
    it can understood by JVM (Java Virtual Machine)
    byte code to the JVM, it will convert the byte code into native machine code.

secured
robust

simple
portable






object oriented
+   class
+   object
+   data hiding:
        making data members as private, so that we cannot access them 
        from other classes directly.
+   encapsulation:
        it is the process accessing private data with the help of public 
        methods.
        it is implemented in the form of public setters and getters.
+   inheritance
+   abstraction
+   polymorphism

Coding Standards:
---------------------
1) Proper Indentation
2) Naming Convensions
        Camel Notation      :   variables, methods
                int length;
                int lengthOfBox


        Pascal Notation     :   class names, interface names
                class Student {

                }

                ArrayIndexOutOfBoundsException
                 
        Uppercase Notation  :   constants

        Lowercase Notation  :   packages

class:  
    It is a user defined datatype that represent an entity
    in terms of properties and behaviours.
    no memory is allocated when we define a class.
    it is a resuable software component.

    classes are used for different purposes. based on the purpose
    we call them different names.
    
    model      :   to store data

object:
    it is a variable whose datatype is class. 
    memory is allocted only when we create an object for a class.

    syntax:
    -------
    ClassName   objectName;             // reference  (stack)
    objectName = new ClassName();       // object      (heap)

  
package:
    collection of classes, interfaces, enums etc.,
    package is represented as a folder in o/s.

                            domain: www.cms.in
                            package name: in.cms

    in.cms.model        :   all the model classes
    in.cms.ui           :   executable programs


access specifiers: (access modifiers):
1) default          : members under this access can be used in the entire package.
2) private          : members can be accessed only within the class in which it
                        is defined.
3) public           : members can be accessed either within the class or from outside
                        the class.

4) protected        : members can be accessed either within the class or from any of
                        it's sub class.


constructors:
------------------
1. it is a special method that is executed automatically whenever an object is created.
2. it should have the same name as that of class.
3. it can not return any value, should not have void as a return type.
4. it can have parameters.
5. a class can have many constructors. 


"this" reference:
------------------
it represent implied object.
implied object is the one which is invoking a methods currently.


static:
-------
static means "sharable".

1. static data members
        these are used to share common data of all objects of the class.

        private static String companyName;


2. static methods

        they can be called directly with the class name.
        it do not require any object to call.

        JVM will  Call our main() like ...

                ComplexNumberApp.main()

        static methods allow only static data members.

        static methods do not allow "this" keyword.


array of objects:
---------------------
    Product[] products = new Product[5];


inheritance:
---------------
    creating a new class (sub class) from an existing class (super class).
    sub class can access all the featurs of super class as well as any extra features
    that are added to it.
    it represent an "is-A" relationship.
    meant for "code usability."
    "extends" keyword is used to create sub classes.


types:
------
1)  simple (single) inheritance
2)  hierarchical inheritance
3)  multi-level inheritance

note:
------
    multiple inheritance is not supported by java using classes.


method overloading:
    when a class contian more than one method having the same name but with different
    parameter list.

    class  Test {
        public void show(int a) {
            System.out.println(a);
        }
        public void show(double a) {
            System.out.println(a);
        }
        public void show(String a) {
            System.our.println(a);
        }
    }

constructor overloading:
    when a class contain multiple constructors

method overriding:
    when a sub class contain a method that has same signature as that of another 
    method in it's super class, then the sub class method is called as 
    overriding method.

    method signature = method name + parameter list

    "@Override" annotation can be used on top of overriding methods.


    class   Super {
        public int add(int a, int b) {
            return a+b;
        }
    }

    class  Sub   extends  Super {
       @Override
        public int add(int a, int b) {      // overriding method
            return a+b+100;
        }
    }

    super:
    -------
        the "super" keyword can used to refer super class data members,
        super class methods, super class constructors from the sub class.

        super();                        call the super class default constructor
        super(arg-1, arg-2, ...)        call the super class parameter constructor
        super.dataMemberName
        super.method(arg-1, arg-2, ...)


                                    Person (name, age)

                                    Employee (salary)               

5-Dec-2022
----------------------

hierarchical inheritance:
--------------------------

                                     Person (name, age)

                        Employee (salary)               Student (fee)

multi level inheritance:
-------------------------

                                    Person (name, age)

                                    Employee (salary) extends Person

                                    Manager (bonus) extends Employee

create the necessary classes and the App also.


polymorphism:
---------------
    poly = many
    morph = forms

    exhibiting different behaviours for a same method call.

                                move()

            man         ----------------------->        walk
            fish        ----------------------->        swim
            bird        ----------------------->        fly
            snake       ----------------------->        crawl

    move() is exhibiting different behaviours and hence it is known as polymohic method.


note:
-----
    super class reference variable can store super class object or objects of any sub class
    of it.


                Peron
    Employee            Student

    Manager


    Person person = new Person();
    Person person = new Employee();
    Person person = new Student();
    Employee employee = new Manager();
    Person person = new Manager();



    Task:
    -----

    class   A {
            public void show() {
                System.out.println("A - show");
            }
        }

        class   B  extends  A {
            public void print() {
                System.out.println("B - print");
            }
        }

        class   Test {
            public static void main(String[] args) {
                B obj = new B();
                obj.show();         // A - show
                obj.print();        // B - print

                A obj2 = new A();
                obj2.show();        // A - show
                obj2.print();       // error


                A obj3 = new B();   
                obj3.show();        // A - show
                obj3.print();       // error
            }
        }


                                    Object class            (java.lang package):
                                   ----------------------------------------------
+   it is known as "universal super class".
+   every class whether it is a pre-defined or user-defined, it is inherited automatically
    from java.lang.Object class.

java.lang.Object class methods:
-------------------------------
1) public String toString()
        it is generally used to convert the object data into string.
        it is provided with default definition.
        (fully-qualified-class-name + "@" + hashcode-in-hexa-decimal-form)

2) public boolean equals(Object o)
        it is used to implement our own logic for object comparision.


                                                abstraction
                                            ---------------------            
abstract means "incomplete".
abstraction is the feature of disclosing only the features without exposing the background functionality.

abstract keyword can be used in two ways.
a) abstract class
b) abstract method


abstract class:
-----------------
    it is a class for which we cannot create an object for it.


                                            abstract class  Person (name, age)

                                Employee (salary)                           Student (fee)


abstract method:
    it is a method declaration with "abstract" keyword without any definition.
    it must be defined only inside an abstract class.
    abstract methods can be defined only in an abstract class. 
    But an abstract class need not contain any abstract methods.

    to make of use of this abstract class, create a sub class and override all abstract methods in it.
    then create objects for this abstract class and use it.


    public abstract class  A {
        public abstract void show();
    }


    class  B  extends  A {
        @Override
        public void show() {
            System.out.println("some definition ...");
        }
    }

    class Test {
        public static void main(String[] args) {
            B obj = new B();
            obj.show();
        }
    }




final:
-------
    can be used in 3 ways.

    a) final variable:
            these are known as constants.

            final double PI = 3.14;
            double areaOfCirlce = PI * radius * radius;  

    b) final methods:

            we cannot override final methods.

            class  Sample {

                public final void show() {
                    // logic
                }

            }

            class  SubSample {

                @Override
                public void show() {
                    // error - we can't override final method
                } 

            }

    c) final class:

            we can't create sub class for it.

            eg: java.lang.Math 





                                                interfaces
                                            -------------------
interface is also user-defined datatype.
it does not contain properties.
it can contain only public abstract methods and public static final variables.
we cannot create object for an interface.

to use the interface, we must create a sub class using "implements" and override all abstract methods.
then create object for this sub class.

using interfaces, we can acheive multiple inheritance.
we can create a class from many interfaces. (multiple inheritance)



class               extends             sub class
interface           implements          sub class
interface           extends             sub interface


class               implements          interface-1, interface-2, ...

class               implements          interface      extends         class


interface   EmployeeRepository {
    void save(Employee employee);
    void findById(Long empId);
}


class       EmployeeRepositoryImpl   implements   EmployeeRepository {

    @Override
    public void save(Employee  employee) {
        // logic goes here ....
    }

    @Override
    piublic void findById(Long empId){
        // logic goes here ...
    }

}

class    Test {
    public static void main(String[] args) {
        EmployeeRepositoryImpl  obj = new EmployeeRepositoryImpl();
        obj.save(new Employee(101, "srinivas", 50000.0));
    }
}


                                        Built-In Packages
						                ------------------
                                        (Java SE Libraries)

java.lang			(default package - because it is imported for every program)
	Object          
	System
	Math
	String
	StringBuffer
	StringBuilder
	Exception
	Throwable interface
	Runnable interface
	Wrapper classes - Integer, Double, Float, Long, Boolean


java.util
    Scanner
   
java.io
    FileReader
    BufferedReader

to use any class, we need to specify fully qualified class name.(eg: packagename.classname) 
or import them.

java.lang is the default package. it is automatically imported for every program.

java.lang.System class:
   -------------------------------

	class variables			              object
	-------------------				    ---------
	public static java.io.InputStream		in
	public static java.io.PrintStream		out
	public static java.io.PrintStream		err

	System.in	carries signal from keyboard to VDU.
	System.out, System.err carries signal directly to VDU.


	methods:
	------------
	public static void gc();		request for garbage collection.
	public static void exit(int)	terminates the program then and there. int could be either a 0 or 1.
    String getEnvironmentVariable(String varName);
    void setEnvironmentVariable(String varName,String value);


java.lang.Math
-------------------
	public static fields:
	------------------------
		E, PI
    	
	public static methods
	----------------------------
		double pow()
		double sin(angle in radians)
            Math.sin(30)    =>  ???
            Math.sin(Math.toRadians(30))    =>  0.5

        double cos(angle in radians)
		double sqrt()

		ceil() : return next integer
            Math.ceil(11.2) => 12
		floor() : return previous integer
            Math.floor(11.9) => 11
		round() 
            Math.round(11.2) =>  11
            Math.round(11.9) =>  12

		abs() : return |n|
		toRadians()
		toDegrees()

java.lang.String
---------------------
	String is immutable	(not modifiable).
    what is immutability?
      ???

	creating object:
	---------------------
	1) String	str;
	2) String	str = new String();

	3) String	str = "hello";
	4) String	str = new String("hello");
  

	methods:
	-------------
	1) length()		2) toUpperCase()		3) toLowerCase()
	4) indexOf(String)	5) lastIndexOf(String)		6) startsWith(String)
	7) endsWith(String)	8) contains(String)		9) charAt(index)
	10) substring(start_index_usiveincl [, end_index_exclusive] )		11) split()
	12) equals(String)	13) equalsIgnoreCase(String)	14) compareTo(String)
	15) valueOf()		16) format()        17) replace(old_char, new_char)

    18) join()  - JDK 1.8

    "+" string concatenation operator


    write a program to reverse a string.
    input = abcd
    output = bcda

    


String constant pool (String literal pool)
------------------------------------------
    This is a special memory used to store string constants.


java.lang.StringBuffer and java.lang.StringBuilder:
------------------------------------------------------------------
	StringBuffer is thread-safe. (synchronized)
	StringBuilder is not thread-safe.

	They are mutable (modifiable).

	a) capacity()
	b) append()
	c) insert()
	d) delete()
	e) reverse()


Wrapper Classes                     static method
---------------------               ---------------------------------
    java.lang.Integer               parseInt(string-form-int)
    java.lang.Short
    java.lang.Byte
    java.lang.Double                parseDouble(string-form-double)
    java.lang.Boolean
    java.lang.Float
    java.lang.Character
    java.lang.Long


every wrapper class provide two constants.
    MIN_VALUE 
    MAX_VALUE


    String str = "123";
    int num = Integer.parseInt(str);        // num = 123
    System.out.println(num * 2);

    System.out.println(Integer.MAX_VALUE);
    System.out.println(Integer.MIN_VALUE);


 Boxing:
    primitive variable into a wrapper object

    int x = 89;
    Integer iobj = x;   //auto-boxing

 unBoxing:
    wrapper object into primitive variable
 
    Integer iobj = new Integer(109);
    int x = iobj; // auto-unboxing

static import: (JDK 1.5)
------------------------
    java.lang.Math class provide static methods.
        sqrt()
        abs()
        pow()

    int a, b;
    double hypotenuse = Math.sqrt(Math.pow(a,2) + Math.pow(b,2));

    (or)
    import static java.lang.Math.sqrt;
    import static java.lang.Math.pow;

    double hypotenuse = sqrt(pow(a,2) + pow(b,2));


    import java.util.Scanner;       // recommended
    import java.util.*;             // bad coding practice



                                    Exception Handling
                                ---------------------------

    Error is detected by the compiler. The program will not be executed until we resolve them.
        a) forgot to put a semi-colon(;)
        b) wrong syntaxes
        c) misspelt names etc.,

    Exception means an unexpected event that is triggered in the program upon which the
    program is abruptly terminated.

    Every exception is a class (pre-defined)

    Exception Details:  (Exception Stack Trace)
    ----------------------------------------------
        what is the exception message?          ...
        what is the exception class name?       java.io.InputMismatchException
        in which package?                       in.cms.ui
        in which class exception occurred?      ExceptionDemo
        in which method exception occurred?     main
        what is the line number?                11
  

    Exception in thread "main" java.lang.ArithmeticException: / by zero
	at in.cms.ui.ExceptionDemo.main(ExceptionDemo.java:18)

        what is the exception message?          / by zero
        what is the exception class name?       java.lang.ArithmeticException
        in which package?                       in.cms.ui
        in which class exception occurred?      ExceptionDemo
        in which method exception occurred?     main
        what is the line number?                18

    If we handle exception, the program will not be terminated. The execution is continued
    by taking an appropriate action regarding that exception.

    To handle exceptions, we have 5 keywords.
        a) try
        b) catch
        c) finally
        d) throw
        c) throws

    try
    {
        // code to be monitored by jvm
        // if ExceptionClassName1 occurred, the control go to the catch block 1, 
            then the finally block.
        // if ExceptionClassName2 occurred, the control go to the catch block 2, 
            then the finally block.
        // if any other exception occurred, it go to the finally block and then 
            the program is terminated.

        // if no exceptions are occurred, then the finally block is executed.

    }
    catch(ExceptionClassName1  excep)
    {
        // action to be taken when the ExceptionClassName1 occurred in the try block.
    }
    catch(ExceptionClassName2  excep)
    {
        // action to be taken when the ExceptionClassName2 occurred in the try block.
    }
    finally
    {
        // action to be taken whether an exception occurred or not.
    }

note:
-----
    every try block must have at least one catch block or finally block.
    we cannot write any statements between try and catch.
    one try block can have many catch blocks.

    one try can have another try within it.



    Exceptions may or maynot reported by the compiler. 
    If exception is not reported by the compiler, it is known as UncheckedExceptions.
    Unchecked exceptions are inherited from java.lang.RuntimeException class.
    Unchecked exceptrions are reported by interpreter (JRE)

    
    if exception is reported by the compiler, it is known as CheckedExceptions.
    CheckedExceptions must be handled using try and catch, then only we can execute the 
    program.
    All checked exceptions are inherited from java.lang.Exception class.



                                        Object

                                        Throwable

                                        Exception

                        IOException                 RuntimeException
                        SQLException
                        ClassNotFoundException              InputMismatchException
                                                            ArithmeticException
                                                            StringIndexOutOfBoundsException
                                                            ArrayIndexOutOfBoundsException
                                                            NegativeArraySizeException

    throw:
        is used to raise an exception explicitly (programmatically)

        syntax:
            throw new UserDefinedExceptionClassName();


                                    user defined exceptions
                                --------------------------------
    1. create a class, must be inherited from Exception class.

    throws:
    -------
        is used to delegate the exception handling reponsibility to the caller
        of the method.



        class   JavaTrainer   {

            public static void main() throws  NetWorkException, TransportException {
                try {
                    throw new DoubtsClarificationException();       // 1.

                    throw new QuickRecapException();                // 2.

                    throw new ResumeBuildingException();            // 3.



                } catch(DoubtsClarificationException excep) {

                } catch(QuickRecapException excep) {

                } catch(ResumeBuildingException excep) {

                }
            }
        }


    class Shopping {

        public void purchase(Card card) throws CardDeclinedException {
            // 
        }

        public void purchase(Cash cash) {
            // payment with cash
        }
    }

    class Customer {
        public void shopping() {
            Shopping shopping = new Shopping();
            try {
                shopping.purchase(creditCard);
            } catch(CardDeclinedException excep) {
                shopping.purchase(cash);
            }
        }
    }


1.card may be blocked.
2.insufficient balance
3.bad network




int a,b,c;

store 1000 numbers?         will you take 1000 variables?       NO


int[] arr = new int[1000];
arr[0] = 10
arr[1] = 5.6;       // not allowed
arr[1] = 20;
arr[2] = 30;
arr[3] = 40;
...

10  20  30  40
10  30  40


        

1. the size of the array is fixed.
2. array is homogeneous.
3. insertion, deletion, sort, search - basic operations are also not supported.


                                            Collections Framework (Collections API)
                                                    (java.util)
                                        ----------------------------------------------
provide set of interfaces, implementation classes, readymade methods.

1. size is not fixed.
2. it can be homogeneous or heterogeneous
3. ready made methods available to do operations.


                                                Collections Hierarchy
                                                ---------------------
                                    

                                    Iterable (i)

                                    Collection (i)                                  Map (i)

                        List (i)                    Set(i)                         

                        ArrayList                       HashSet                     HashMap 
                        LinkedList                      LinkedHashSet               LinkedHashMap
                                                        TreeSet                     TreeMap

Collections are used to store objects.

1) raw collection           (heterogeneous - not recommended)
2) generic collection       (homogeneous - recommended)
    provide type safety.


cursors:
---------
1) Iterator




List:
    1. duplicates are allowed.
    2. index based operations

    add()
    remove()
    set()
    get()
    size()

    ArrayList:
    ----------
        List list = new ArrayList();

        ArrayList list = new ArrayList();

        clear()     :   to remove all elements
        contains()  :   to search for an element

        is best when modifications are less frequent.

    LinkedList:
    ------------
        List list = new LinkedList();

        LinkedList list = new LinkedList();

        is best when modifications are frequent.

        a) addFirst()
        b) addLast()
        c) removeFirst()
        d) removeLast()

    Queue:
    ---------
        FIFO



Set:
    1. no duplicates
    2. no index based operations


    HashSet             :   order is not guaranteed
    LinkedHashSet       :   insertion order
    TreeSet             :   sorted order

    does set allow null values?



Map:
    1. collection of key-value pairs.
    2. key cannot be duplicated.
    3. value can be duplicated.
    4. key cannot be null.
    5. value can be null.
    6. do not follow index

    HashMap             :   order is not guaranteed
    LinkedHashMap       :   insertion order
    TreeMap             :   sorted order on key

    put(key, value)
    value get(key)































Assignments:
------------
1) include toString() in Person, Employee, Student, Manager class.
   modify the InheritanceApp program accordingly.

2) Create a Product class
        prodName, price
   Store 10 products in an array.
   write a program to display all the products.


3) What is the antonym keyword  for "final"?
4) what is the difference between JDK, JVM, JRE?
5) can we overload static methods?  
6) can we override static methods?          
7) can we have static classes?


8) what is static block?



create a class called "Point".
    data members : x, y
    initialize the point object with 0,0 if no values are given.
    initialize the point object with the given values.
    find the distance between to given points.
    find the mid point of two given points.
    find whether three given points form a triangle or not.

    No need to write the App. It can be done later.

Reverse String program using StringBuilder.







































